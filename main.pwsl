// EarthOS kernel
//
//    Copyright (C) 2021  adazem009
//
// This is the main source code of the EarthOS kernel. I won't explain how the kernel works here,
// use the docs (if I've written some) for that.
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Some notes:
// There are functions that use a loop to determine if something
// exists in a list. This is SLOW and SPACE CONSUMING. Replace
// it by getindex/[list name],[item]/[output var] and if output is
// 0, then it doesn't exist, wherever possible!
//
// Functions
linkdef/"kmsg","kmsg","global"
{
	warp
		// kmsg/[source],[color],[message],[message],...
		getlistlength/"arg_1"/"kmc"
		calc/"kup=%time-$kstart"/2
		set/"ts","[ ",kup," ] "/"kmi",0
		//print/"ˇ000255000ˇ",ts
		print/\c"000255000",ts
		getlength/ts/"tsl"
		getitem/"arg_1",2/"kmcl"
		repeat/kmc
			calc/"kmi=kmi+1"
			getitem/"arg_1",kmi/"km"
			if/[km == "\n"] and [kmi > 2]
				print/\n
				calc/"tsl2=tsl-1"
				// ^^^ Fix an incorrect text alignment
				repeat/tsl2
					print/" "
				endloop
			else
				if/[km != ""]
					if/[kmi == 1]
						print/\c"2461160",km,": "
					else
						// I know this is duplicate, but the colored
						// text is a bit broken in SMC Computer, so
						// I used this workaround
						if/[kmi > 2]
							//print/km
							print/\ckmcl,km
						endif
					endif
				else
					if/[kmi > 2]
						//print/km
						print/\ckmcl,km
					endif
				endif
			endif
		endloop
		print/\n
	endwarp
}
linkdef/"pidkmsg","pidkmsg","global"
{
	warp
		// pidkmsg/[color],[message]
		getitem/"arg_1",1/"msgc"
		getitem/"arg_1",2/"msgt"
		set/"msgp","pid ",pid
		kmsg/msgp,msgc,msgt
	endwarp
}
linkdef/"PANIC","pan","global"
{
	// PANIC/[error description]
	warp
		getitem/"arg_1",1/"panicdesc"
		kmsg/"Kernel panic",255000000,"\n",panicdesc
		// Uncomment the lines below to enable auto reboot after panic
		//kmsg/"",255255255,"Rebooting in 10 seconds..."
	endwarp
	//wait/10
	//reboot
	// The lines below should be commented out if auto reboot is enabled
	while/[true]
		// nothing here
		wait/1000
	endloop
}
linkdef/"_listpart","lpt","global"
{
	warp
		// _listpart/[partition table image]/[output list - names],[output list - sizes],[output list - data]
		getitem/"arg_1",1/"ptim"
		getitem/"arg_2",1/"oln"
		getitem/"arg_2",2/"ols"
		getitem/"arg_2",3/"old"
		bintolist/ptim/"ptlist"
		getlistlength/"ptlist"/"ptl"
		setlist/oln,ols,old
		set/"lpi",0
		while/[lpi < ptl]
			// Partition name
			calc/"lpi=lpi+1"
			getitem/"ptlist",lpi/"pr"
			append/pr/oln
			// Partition size
			calc/"lpi=lpi+1"
			getitem/"ptlist",lpi/"pr"
			append/pr/ols
			// Partition content
			calc/"lpi=lpi+1"
			getitem/"ptlist",lpi/"pr"
			append/pr/old
		endloop
	endwarp
}
linkdef/"resolvedev","rsd","global"
{
	warp
		// resolvedev/[path]
		getitem/"arg_1",1/"devp"
		set/"dvn","$",devp/"rdi",0/"dlt",""
		readvar/dvn/"dv"
		setlist/"dl"
		getlength/dv/"dvl"
		repeat/dvl
			calc/"rdi=rdi+1"
			getletter/dv,rdi/"rdl"
			if/[rdl == ","]
				append/dlt/"dl"
				set/"dlt",""
			else
				set/"dlt",dlt,rdl
			endif
		endloop
		append/dlt/"dl"
	endwarp
}
linkdef/"_ls","ls","global"
{
	warp
		// _ls/[path],[fs image]/[output list - types],[output list - names],[output list - data]
		getitem/"arg_1",1/"path"
		getitem/"arg_1",2/"fs"
		getitem/"arg_2",1/"olt"
		getitem/"arg_2",2/"oln"
		getitem/"arg_2",3/"old"
		setlist/olt,oln,old
		// Convert binary
		bintolist/fs/"fsl"
		getlistlength/"fsl"/"fsll"
		set/"i",1/"loop",1
		//      ^ This is 1 because the first item is the filesystem format (FSSC2 in this case)
		while/[i < fsll]
			if/[loop == 1]
				// Definition path
				calc/"i=i+1"
				getitem/"fsl",i/"def"
				//print/"def=",def,\n
				// Number of files
				calc/"i=i+1"
				getitem/"fsl",i/"c"
				//print/"c=",c,\n
				if/[c > 0]
					set/"loop",0/"ci",0
				endif
			else
				// Get files under current definition
				calc/"ci=ci+1"
				// Type - file or folder
				calc/"i=i+1"
				getitem/"fsl",i/"ft"
				// File name
				calc/"i=i+1"
				getitem/"fsl",i/"fn"
				//print/fn,\n
				// File data
				calc/"i=i+1"
				getitem/"fsl",i/"fd"
				// Skip permissions, owner, group and attributes
				calc/"i=i+4"
				if/[def == path]
					append/ft/olt
					append/fn/oln
					append/fd/old
				endif
				if/[ci >= c]
					set/"loop",1
				endif
			endif
		endloop
	endwarp
}
linkdef/"_fixpath","fixpt","global"
{
	warp
		// _fixpath/[path]/[output variable]
		getitem/"arg_1",1/"path"
		getitem/"arg_2",1/"out"
		getlength/path/"len"
		set/"cur",pwd
		setlist/"parts"
		set/"i",0/"part",""
		while/[i < len]
			calc/"i=i+1"
			getletter/path,i/"let"
			if/[let == "/"] or [i == len]
				if/[i == len]
					set/"part",part,let
				endif
				if/[i == 1]
					set/"part",""/"cur","/"
				endif
				append/part/"parts"
				if/[part == "."] or [part == ""]
					// Go to pwd
					// this needn't be defined
				else
					if/[part == ".."]
						// Go up
						getlength/cur/"len2"
						setlist/"parts2"
						set/"part2",""/"i2",0
						repeat/len2
							calc/"i2=i2+1"
							getletter/cur,i2/"let"
							if/[let == "/"] or [i2 == len2]
								if/[i2 > 1]
									if/[i2 == len2]
										set/"part2",part2,let
									endif
									append/part2/"parts2"
									set/"part2",""
								endif
							else
								set/"part2",part2,let
							endif
						endloop
						getlistlength/"parts2"/"len2"
						sub/len2,1/"len2"
						set/"cur",""/"i2",0
						repeat/len2
							calc/"i2=i2+1"
							getitem/"parts2",i2/"it"
							set/"cur",cur,"/",it
						endloop
					else
						if/[cur == "/"]
							set/"cur","/",part
						else
							set/"cur",cur,"/",part
						endif
					endif
				endif
				set/"part",""
			else
				set/"part",part,let
			endif
		endloop
		set/out,cur
	endwarp
}
linkdef/"_set","set","global"
{
	warp
		// _set/[var name],[value]
		// This function was ported from SMC Computer.
		getitem/"arg_1",1/"varn"
		getitem/"arg_1",2/"varv"
		getletter/varn,1/"flvn"
		bintolist/$gl_vn/"gl_vn"
		bintolist/$gl_vv/"gl_vv"
		if/[flvn == "$"]
			set/"nvarn","gl_vn"
			set/"nvarv","gl_vv"
		else
			set/"nvarn","vn"
			set/"nvarv","vv"
		endif
		set/"seti",0
		getlistlength/nvarn/"settmp"
		set/"found",0
		while/[seti < settmp]
			calc/"seti=seti+1"
			getitem/nvarn,seti/"name"
			if/[name == varn]
				set/"found",1
			endif
		endloop
		if/[found == 0]
			append/varn/nvarn
			append/varv/nvarv
		else
			getindex/nvarn,varn/"tmp"
			replace/tmp,varv/nvarv
		endif
		listtobin/"gl_vn"/"$gl_vn"
		listtobin/"gl_vv"/"$gl_vv"
	endwarp
}
linkdef/"_envsetup","envsetup","global"
{
	//warp
		// _envsetup
		// (no arguments)
		//
		// Variables
		set/"pcol","255255255"/"pwd","/"
		// Lists
		setlist/"vn","vv","listn","listc","i_tree","bin_tree"
		// User check
		bintolist/$USERS/"USERS"
		getindex/"USERS",whoami/"ix"
		if/[ix == 0]
			set/"msg","user '",whoami,"' not found"
			source/$tmp_lib_pidkmsg/255000000,msg
			set/"envrt",1
			exit
		endif
		// Environment variables
		// NOTE for environment variables (read before adding your own variables):
		// I had to implement a quicker updating. The variables are
		// initialized in this function and _envupdate quickly overwrites the entries.
		append/"%user"/"vn"
		append/"%time"/"vn"
		append/"%fps"/"vn"
		append/"%uptime"/"vn"
		append/"%kuptime"/"vn"
		append/"%cpu"/"vn"
		append/"%ps"/"vn"
		append/"%pid"/"vn"
		append/"%whoami"/"vn"
		append/"%pwd"/"vn"
		getlistlength/"vn"/"len"
		repeat/len
			append/""/"vv"
		endloop
	//endwarp
}
linkdef/"_envupdate","envupdate","global"
{
	// _envupdate
	// (no arguments)
	// This function was ported from SMC Computer.
	// It has some EarthOS-specific additions.
	//
	// These variables must be created before calling this function!
	//
	// Username
	replace/1,%user/"vv"
	// Timestamp (seconds since 2000)
	replace/2,%time/"vv"
	// FPS
	replace/3,%fps/"vv"
	// BIOS Uptime (in seconds)
	replace/4,%uptime/"vv"
	// Kernel uptime (in seconds)
	calc/"tmp=%time-$kstart"
	replace/5,tmp/"vv"
	// CPU usage (in %) - depends on FPS
	replace/6,%cpu/"vv"
	// Number of running processes
	getlistlength/"processes"/"tmp"
	replace/7,tmp/"vv"
	// Process ID
	replace/8,pid/"vv"
	// User
	replace/9,whoami/"vv"
	// Current directory
	replace/10,pwd/"vv"
}
linkdef/"skip_loop","skl","global"
{
	warp
		set/"si",res1/"pos",0
		bintolist/$gl_vn/"gl_vn"
		bintolist/$gl_vv/"gl_vv"
		getitem/"command",1/"it"
		while/[it == 3] nand [pos == 0]
			calc/"si=si+1"
			smc_getarg/"script",si,"vn","vv","gl_vn","gl_vv"/"si2","command","argument"
			getitem/"command",1/"it"
			set/"si",si2/"res1",si2
			if/[it == 2] or [it == 7]
				calc/"pos=pos+1"
			endif
			if/[it == 3] and [pos > 0]
				calc/"pos=pos-1"
			endif
		endloop
		listtobin/"gl_vn"/"$gl_vn"
		listtobin/"gl_vv"/"$gl_vv"
	endwarp
}
linkdef/"skip_if","ski","global"
{
	warp
		set/"si",res1/"pos",1
		bintolist/$gl_vn/"gl_vn"
		bintolist/$gl_vv/"gl_vv"
		getitem/"command",1/"it"
		while/[it == 5] nand [pos == 0]
			calc/"si=si+1"
			smc_getarg/"script",si,"vn","vv","gl_vn","gl_vv"/"si2","command","argument"
			getitem/"command",1/"it"
			set/"si",si2/"res1",si2
			if/[it == 4]
				calc/"pos=pos+1"
			endif
			if/[it == 5]
				calc/"pos=pos-1"
			endif
		endloop
		listtobin/"gl_vn"/"$gl_vn"
		listtobin/"gl_vv"/"$gl_vv"
	endwarp
}
linkdef/"_if","if","global"
{
	warp
		// _if/[global? 1/0],[global custom ID]
		// This function was ported from SMC Computer.
		bintolist/$gl_vn/"gl_vn"
		bintolist/$gl_vv/"gl_vv"
		getitem/"arg_1",1/"gl?"
		if/[gl? == 1]
			getitem/"arg_1",2/"cid"
		else
			set/"gl?",0/"cid",si
		endif
		setlist/"gates"
		set/"si3",0
		getlistlength/"command"/"cmdl"
		calc/"cmdl=cmdl-1"
		repeat/cmdl
			calc/"si3=si3+1"
			smc_getarg/"script",cid,"vn","vv","gl_vn","gl_vv"/"si2","command","argument"
			set/"ln","argument",si3
			mod/si3,2/"md"
			if/[md == 1]
				set/"go",0
				getitem/ln,2/"op"
				getitem/ln,1/"A1"
				getitem/ln,3/"A2"
				if/[op == "=="]
					// A1 equals A2
					if/[A1 == A2]
						set/"go",1
					else
						set/"go",0
					endif
				else
					if/[op == "!="]
						// NOT A1 equals A2
						if/[A1 == A2]
							set/"go",0
						else
							set/"go",1
						endif
					else
						if/[op == ">"]
							// A1 is greater than A2
							if/[A1 > A2]
								set/"go",1
							else
								set/"go",0
							endif
						else
							if/[op == "!>"]
								// NOT A1 is greater than A2
								if/[A1 !> A2]
									set/"go",1
								else
									set/"go",0
								endif
							else
								if/[op == "<"]
									// A1 is lower than A2
									if/[A1 < A2]
										set/"go",1
									else
										set/"go",0
									endif
								else
									if/[op == "!<"]
										// NOT A1 is lower than A2
										if/[A1 !< A2]
											set/"go",1
										else
											set/"go",0
										endif
									else
										if/[op == ">="]
											// A1 is greater or equal to A2
											if/[A1 >= A2]
												set/"go",1
											else
												set/"go",0
											endif
										else
											if/[op == "!<="]
												// NOT A1 is greater or equal to A2
												if/[A1 !<= A2]
													set/"go",1
												else
													set/"go",1
												endif
											else
												if/[op == "<="]
													// A1 is lower or equal to A2
													if/[A1 <= A2]
														set/"go",1
													else
														set/"go",1
													endif
												else
													if/[op == "!<="]
														// NOT A1 is lower or equal to A2
														if/[A1 !<= A2]
															set/"go",1
														else
															set/"go",1
														endif
													endif
												endif
											endif
										endif
									endif
								endif
							endif
						endif
					endif
				endif
				getitem/ln,4/"aop"
				if/[aop == "!"]
					// NOT
					calc/"go=1-go"
				endif
				append/go/"gates"
			else
				getitem/ln,1/"op"
				append/op/"gates"
			endif
		endloop
		set/"go",0/"i2",0
		getlistlength/"gates"/"cmdl"
		if/[cmdl == 1]
			getitem/"gates",1/"go"
		endif
		// ^^^ I used cmdl here because it isn't used by anything.
		calc/"cmdl=cmdl-1"
		div/cmdl,2/"cmdl"
		repeat/cmdl
			calc/"i2=i2+2"
			setlist/"gate"
			if/[i2 == 2]
				calc/"tmp=i2-1"
				getitem/"gates",tmp/"tmp"
				append/tmp/"gate"
			else
				append/go/"gate"
			endif
			getitem/"gates",i2/"tmp"
			append/tmp/"gate"
			calc/"tmp=i2+1"
			getitem/"gates",tmp/"tmp"
			append/tmp/"gate"
			getitem/"gate",2/"op"
			getitem/"gate",1/"A1"
			getitem/"gate",3/"A2"
			calc/"sum=A1+A2"
			if/[op == "&&"]
				// AND
				if/[sum == 2]
					set/"go",1
				else
					set/"go",0
				endif
			else
				if/[op == "!&"]
					// NAND
					if/[sum != 2]
						set/"go",1
					else
						set/"go",0
					endif
				else
					if/[op == "||"]
						// OR
						if/[sum != 0]
							set/"go",1
						else
							set/"go",0
						endif
					else
						if/[op == "!|"]
							// NOR
							if/[sum == 0]
								set/"go",1
							else
								set/"go",0
							endif
						else
							if/[op == "//"]
								// XOR
								if/[sum == 1]
									set/"go",1
								else
									set/"go",0
								endif
							else
								if/[op == "!/"]
									// XNOR
									if/[sum != 1]
										set/"go",1
									else
										set/"go",0
									endif
								endif
							endif
						endif
					endif
				endif
			endif
		endloop
		if/[gl? == 0] and [go == 0]
			set/"si",res1/"pos",1/"c",0
			while/[c == 0]
				calc/"si=si+1"
				smc_getarg/"script",si,"vn","vv","gl_vn","gl_vv"/"si2","command","argument"
				set/"si",si2/"res1",si2
				getitem/"command",1/"opc"
				if/[opc == 4]
					calc/"pos=pos+1"
				endif
				if/[opc == 5] and [pos > 0]
					calc/"pos=pos-1"
				endif
				if/[opc == 5] and [pos == 0]
					set/"c1",1
				else
					set/"c1",0
				endif
				if/[opc == 6] and [pos == 1]
					set/"c2",1
				else
					set/"c2",0
				endif
				if/[c1 == 1] or [c2 == 1]
					set/"c",1
				else
					set/"c",0
				endif
			endloop
		endif
		listtobin/"gl_vn"/"$gl_vn"
		listtobin/"gl_vv"/"$gl_vv"
	endwarp
}
linkdef/"fileop","fop","global"
{
	// fileop/[path]
	getitem/"arg_1",1/"in"
	source/$tmp_lib_fixpt/in/"path"
	// The last item is our file name
	getlistlength/"parts"/"len"
	getitem/"parts",len/"gname"
	set/"path",in,"/.."
	// ^ This will make _fixpath ignore the last part of the path
	source/$tmp_lib_fixpt/path/"path"
	source/$tmp_lib_ls/path,$rootfs/"ftypes","fnames","fdata"
	getindex/"fnames",gname/"ix"
}
linkdef/"_poweroff","poweroff","global"
{
	endwarp
		// _poweroff/[wait time in secs]
		getitem/"arg_1",1/"wait"
		source/$tmp_lib_kmsg/"","003119252","System power off"
		wait/in
		shutdown
	warp
}
linkdef/"_reboot","reboot","global"
{
	endwarp
		// _reboot/[wait time in secs]
		getitem/"arg_1",1/"wait"
		source/$tmp_lib_kmsg/"","003119252","System restart"
		wait/in
		reboot
	warp
}
// --- START EMC instructions ---
linkdef/"emc0","emc0","global"
{
	// Exit.
	// 0
	getlistlength/"script"/"si"
	set/"res1",si
}
linkdef/"emc1","emc1","global"
{
	// Number: Go forward a number of lines.
	// !Number: Jump to a line.
	// 1/[value]
	getitem/"argument1",1/"in"
	getletter/in,1/"let"
	if/[let == "!"]
		set/"temp",""/"i2",1
		getlength/in/"len"
		calc/"len=len-1"
		repeat/len
			calc/"i2=i2+1"
			getletter/in,i2/"let"
			set/"temp",temp,let
		endloop
		calc/"si=temp-1"
	else
		calc/"in2=in-1"
		calc/"si=si+in2"
	endif
}
linkdef/"emc2","emc2","global"
{
	// Repeat loop.
	// 2/[count]
	if/[in <= 0]
		source/$tmp_lib_skl
		set/"opcode",""
	else
		append/1/"loops-i"
		append/si/"loops-id"
		getitem/"argument1",1/"in"
		append/in/"loops-max"
	endif
}
linkdef/"emc3","emc3","global"
{
	// The end of the last loop.
	// 3
	bintolist/$gl_vn/"gl_vn"
	bintolist/$gl_vv/"gl_vv"
	getlistlength/"loops-i"/"lil"
	getitem/"loops-i",lil/"lit"
	getitem/"loops-max",lil/"lit2"
	if/[lit == 0]
		// End of while loop.
		smc_getarg/"script",lit2,"vn","vv","gl_vn","gl_vv"/"si2","command","argument"
		source/$tmp_lib_if/1,lit2
		if/[go == 1]
			getitem/"loops-id",lil/"si"
			smc_getarg/"script",si,"vn","vv","gl_vn","gl_vv"/"si2","command","argument"
			set/"si",si2/"res1",si2
		else
			deleteitem/lil/"loops-i"
			deleteitem/lil/"loops-id"
			deleteitem/lil/"loops-max"
		endif
	else
		// End of repeat loop.
		if/[lit < lit2]
			calc/"new=lit+1"
			replace/lil,new/"loops-i"
			getitem/"loops-id",lil/"si"
			source/$tmp_lib_envupdate
			smc_getarg/"script",si,"vn","vv","gl_vn","gl_vv"/"si2","command","argument"
			set/"si",si2/"res1",si
		else
			deleteitem/lil/"loops-i"
			deleteitem/lil/"loops-id"
			deleteitem/lil/"loops-max"
		endif
	endif
	listtobin/"gl_vn"/"$gl_vn"
	listtobin/"gl_vv"/"$gl_vv"
}
linkdef/"emc4","emc4","global"
{
	// If.
	// 4/<condition...>
	source/$tmp_lib_if
}
//linkdef/"emc5","emc5"
//{
	// End if.
	// 5
//}
linkdef/"emc6","emc6","global"
{
	// Else.
	// 6
	source/$tmp_lib_ski
}
linkdef/"emc7","emc7","global"
{
	// While loop.
	// 7/<condition ...>
	source/$tmp_lib_if/1,si
	if/[go == 1]
		append/0/"loops-i"
		append/si/"loops-id"
		append/si/"loops-max"
	else
		source/$tmp_lib_skl
	endif
}
//linkdef/"emc8","emc8","global"
//{
	// Reserved
//}
//linkdef/"emc9","emc9","global"
//{
	// Reserved
//}
linkdef/"emcA","emc10","global"
{
	// Print.
	// A/[string]/[bold],[italic],[underlined]
	// This needs more work
	getitem/"argument1",1/"in"
	getitem/"argument2",1/"in1"
	getitem/"argument2",2/"in2"
	getitem/"argument2",3/"in3"
	if/[pcol == "255255255"]
		print/\bin1,\iin2,\uin3,in,\b0,\i0,\u0
	else
		print/\bin1,\iin2,\uin3,\cpcol,in,\b0,\i0,\u0
	endif
}
linkdef/"emcB","emc11","global"
{
	// Ask and save to variable in input 2 of argument 1.
	// B/[string],[variable]
	// This needs more work
	getitem/"argument1",1/"in1"
	getitem/"argument1",2/"in2"
	endwarp
		read/in1,"emctmp"
	warp
	source/$tmp_lib_set/in2,emctmp
}
linkdef/"emcC","emc12","global"
{
	// Wait for a(ny) key to be pressed.
	// Input 1 of argument 1 is the key.
	// Input 2 of argument 1 (0 or 1) toggles release waiting. It'll wait until you release the key after you pressed it.
	// C/[value]
	getitem/"argument1",1/"in"
	keywait/in
}
linkdef/"emcD","emc13","global"
{
	// Clear the screen.
	// D
	// This needs more work
	clear
}
linkdef/"emcE","emc14","global"
{
	// Print a newline.
	// E
	// This needs more work
	print/\n
}
linkdef/"emcF","emc15","global"
{
	// Operations.
	// F/[operation ID(s)]/[target variable(s)]/[inputs]/[scale]
	set/"scale",16/"i2",0
	getitem/"argument4",1/"in"
	if/[in != ""]
		set/"scale",in
	endif
	setlist/"ops"/""
	getlistlength/"argument4"/"len"
	repeat/len
		calc/"i2=i2+1"
		getitem/"argument4",i2/"in"
		append/in/"ops"
	endloop
	getlistlength/"argument3"/"len"
	set/"temp2",0/"i2",0
	repeat/len
		calc/"i2=i2+1"
		getitem/"argument3",i2/"in"
		if/[i2 == 1]
			set/"temp2",in
		else
			getitem/"ops",i2/"op"
			if/[op == 1]
				add/temp2,in/"temp2"
			endif
			if/[op == 2]
				sub/temp2,in/"temp2"
			endif
			if/[op == 3]
				multi/temp2,in/"temp2"
			endif
			if/[op == 4]
				div/temp2,in/"temp2"
			endif
			if/[op == 5]
				mod/temp2,in/"temp2"
			endif
		endif
	endloop
	getlistlength/"argument2"/"len"
	set/"i2",0
	repeat/len
		calc/"i2=i2+1"
		getitem/"argument2",i2/"in"
		source/$tmp_lib_set/in,temp2
	endloop
}
linkdef/"emc10","emc16","global"
{
	// Set variable(s) to value(s).
	// 10/[var name],[value]/[var name],[value]/...
	getlistlength/"command"/"len"
	calc/"len=len-1"
	set/"i3",0
	repeat/len
		calc/"i3=i3+1"
		set/"an","argument",i3
		getlistlength/an/"len2"
		calc/"len2=len2-1"
		set/"temp",""/"i4",1
		repeat/len2
			calc/"i4=i4+1"
			getitem/an,i4/"in"
			set/"temp",temp,in
		endloop
		getitem/an,1/"in"
		source/$tmp_lib_set/in,temp
	endloop
}
linkdef/"emc11","emc17","global"
{
	// Round a value and write the result into variable(s).
	// 11/[value],[number of digits]/[variable(s)]
	getitem/"argument1",1/"in1"
	getitem/"argument1",2/"in2"
	round/in1,in2/"temp2"
	getlistlength/"argument2"/"len"
	set/"i2",0
	repeat/len
		calc/"i2=i2+1"
		getitem/"argument2",i2/"in"
		source/$tmp_lib_set/in,temp2
	endloop
}
linkdef/"emc12","emc18","global"
{
	// Get letter of a string and save it in variable(s).
	// 12/[string],[letter]/[variable(s)]
	getitem/"argument1",1/"in1"
	getitem/"argument1",2/"in2"
	getletter/in1,in2/"temp2"
	getlistlength/"argument2"/"len"
	set/"i2",0
	repeat/len
		calc/"i2=i2+1"
		getitem/"argument2",i2/"in"
		source/$tmp_lib_set/in,temp2
	endloop
}
linkdef/"emc13","emc19","global"
{
	// Get length of a string and save it in variable(s).
	// 13/[string]/[variable(s)]
	getitem/"argument1",1/"in"
	getlength/in/"temp2"
	getlistlength/"argument2"/"len"
	set/"i2",0
	repeat/len
		calc/"i2=i2+1"
		getitem/"argument2",i2/"in"
		source/$tmp_lib_set/in,temp2
	endloop
}
linkdef/"emc14","emc20","global"
{
	// Setup list(s).
	// 14/[list name(s)]/[items]
	listtobin/"argument2"/"temp2"
	getlistlength/"argument1"/"len"
	set/"i2",0
	repeat/len
		calc/"i2=i2+1"
		getitem/"argument1",i2/"in"
		getlistlength/"listn"/"len2"
		set/"i3",0/"con",0
		while/[i3 < len2]
			calc/"i3=i3+1
			getitem/"listn",i3/"it"
			if/[it == in]
				set/"i3",len2/"con",1
			endif
		endloop
		if/[con == 0]
			append/in/"listn"
			append/""/"listc"
		endif
		getindex/"listn",in/"ix"
		replace/ix,temp2/"listc"
	endloop
}
linkdef/"emc15","emc21","global"
{
	// Append to list.
	// 15/[string]/[list name]
	getitem/"argument1",1/"in1"
	getitem/"argument2",1/"in2"
	getlength/in1/"il"
	getlistlength/"listn"/"len2"
	set/"i3",0/"con",0
	while/[i3 < len2]
		calc/"i3=i3+1
		getitem/"listn",i3/"it"
		if/[it == in2]
			set/"i3",len2/"con",1
		endif
	endloop
	if/[con == 1]
		getindex/"listn",in2/"ix"
		getitem/"listc",ix/"it"
		set/"it",it,il,";",in1
		replace/ix,it/"listc"
	else
		append/in2/"listn"
		set/"it",il,";",in1
		append/it/"listc"
	endif
}
linkdef/"emc16","emc22","global"
{
	// Replace item in list.
	// 16/[item],[string]/[list name]
	getitem/"argument1",1/"in1"
	getitem/"argument1",2/"in2"
	getitem/"argument2",1/"in3"
	getlistlength/"listn"/"len2"
	set/"i3",0/"con",0
	while/[i3 < len2]
		calc/"i3=i3+1"
		getitem/"listn",i3/"it"
		if/[it == in3]
			set/"i3",len2/"con",1
		endif
	endloop
	if/[con == 1]
		getindex/"listn",in2/"ix"
		getitem/"listc",ix/"it"
		bintolist/it/"new"
		replace/in1,in2/"new"
		listtobin/"new"/"it"
		replace/ix,it/"listc"
	else
		append/in2/"listn"
		append/""/"listc"
	endif
}
linkdef/"emc17","emc23","global"
{
	// Insert item to list.
	// 17/[item],[string]/[list name]
	getitem/"argument1",1/"in1"
	getitem/"argument1",2/"in2"
	getitem/"argument2",1/"in3"
	getlistlength/"listn"/"len2"
	set/"i3",0/"con",0
	while/[i3 < len2]
		calc/"i3=i3+1
		getitem/"listn",i3/"it"
		if/[it == in3]
			set/"i3",len2/"con",1
		endif
	endloop
	if/[con == 1]
		getindex/"listn",in2/"ix"
		getitem/"listc",ix/"it"
		bintolist/it/"new"
		insert/in1,in2/"new"
		listtobin/"new"/"it"
		replace/ix,it/"listc"
	else
		append/in2/"listn"
		set/"it",il,";",in1
		append/it/"listc"
	endif
}
linkdef/"emc18","emc24","global"
{
	// Get item from list.
	// 18/[list name],[item]/[variable(s)]
	getitem/"argument1",1/"in"
	getindex/"listn",in/"ix"
	getitem/"listc",ix/"it"
	bintolist/it/"list"
	getitem/"argument1",2/"in"
	getitem/"list",in/"temp2"
	getlistlength/"argument2"/"len"
	set/"i2",0
	repeat/len
		calc/"i2=i2+1"
		getitem/"argument2",i2/"in"
		source/$tmp_lib_set/in,temp2
	endloop
}
linkdef/"emc19","emc25","global"
{
	// Get length of list.
	// 19/[list name]/[variable(s)]
	getitem/"argument1",1/"in"
	getindex/"listn",in/"ix"
	getitem/"listc",ix/"it"
	bintolist/it/"list"
	getlistlength/"list"/"temp2"
	getlistlength/"argument2"/"len"
	set/"i2",0
	repeat/len
		calc/"i2=i2+1"
		getitem/"argument2",i2/"in"
		source/$tmp_lib_set/in,temp2
	endloop
}
linkdef/"emc1A","emc26","global"
{
	// Run binary.
	// 1A/[code],[wait or bg]/[arg1]/[arg2]/...
	getitem/"argument1",1/"code"
	getitem/"argument1",2/"temp2"
	calc/"c=arg_count-1"
	setlist/"args"
	set/"i3",0
	repeat/c
		calc/"i3=i3+1"
		calc/"temp=i3+1"
		set/"temp","arg_",temp
		listtobin/temp/"bin"
		append/bin/"args"
	endloop
	listtobin/"args"/"args_pass"
	run/$tmp_lib_start,temp2/code,temp2/args_pass
}
linkdef/"emc1B","emc27","global"
{
	// Source.
	// 1B/[code],[wait or bg]/[arg1]/[arg2]/...
	getitem/"argument1",1/"code"
	getitem/"argument1",2/"temp2"
	calc/"c=arg_count-1"
	setlist/"args"
	set/"i3",0
	repeat/c
		calc/"i3=i3+1"
		calc/"temp=i3+1"
		set/"temp","arg_",temp
		listtobin/temp/"bin"
		append/bin/"args"
	endloop
	if/[temp2 == "bg"]
		// bg source not supported yet, even in SMC Computer
		source/$tmp_lib_pidkmsg/255000000,"source: bg not supported"
	else
		listtobin/"args"/"args_pass"
		append/res1/"i_tree"
		append/script_bin/"bin_tree"
		source/$tmp_lib_emc,temp2/code,pid/args_pass
		getitem/"i_tree","last"/"si"
		getitem/"bin_tree","last"/"script_bin"
		deleteitem/"last"/"i_tree"
		deleteitem/"last"/"bin_tree"
		set/"res1",si
		listtobin/script_bin/"script"
	endif
}
linkdef/"emc1C","emc28","global"
{
	// Get currently pressed keys and save them in a list.
	// 1C/[list name]
	getitem/"argument1",1/"in"
	getkey/"list"
	listtobin/"list"/"bin"
	getlistlength/"listn"/"len2"
	set/"i3",0/"con",0
	while/[i3 < len2]
		calc/"i3=i3+1
		getitem/"listn",i3/"it"
		if/[it == in]
			set/"i3",len2/"con",1
		endif
	endloop
	if/[con == 1]
		getindex/"listn",in/"ix"
		replace/ix,bin/"listc"
	else
		append/in/"listn"
		append/bin/"listc"
	endif
}
linkdef/"emc1D","emc29","global"
{
	// Set background color.
	// 1D/[RRRGGGBBB]
	getitem/"argument1",1/"in"
	bgcolor/in
}
//linkdef/"emc1E","emc30","global"
//{
	// Warp.
	// 1E
	//
	// Nothing here, everything is already running in warp mode.
//}
//linkdef/"emc1F","emc31","global"
//{
	// End warp.
	// 1F
//}
linkdef/"emc20","emc32","global"
{
	// Wait.
	// 20/[seconds]
	getitem/"argument1",1/"in"
	endwarp
		wait/in
	warp
}
linkdef/"emc21","emc33","global"
{
	// Set text color.
	// 21/[RRRGGGBBB]
	getitem/"argument1",1/"pcol"
}
linkdef/"emc22","emc34","global"
{
	// Change directory
	// 22/[path]
	getitem/"argument1",1/"in"
	source/$tmp_lib_fixpt/in/"in"
	set/"pwd",in
}
linkdef/"emc23","emc35","global"
{
	// Get current directory.
	// 23/[output variable]
	getitem/"argument1",1/"in"
	source/$tmp_lib_set/in,pwd
}
linkdef/"emc24","emc36","global"
{
		// Read file.
		// 24/[path]/[output list]
		getitem/"argument1",1/"in1"
		getitem/"argument2",1/"in2"
		source/$tmp_lib_fop/in1
		// We got the file data below
		getitem/"fdata",ix/"file"
		// Now, it needs to save it in the list
		while/[i3 < len2]
			calc/"i3=i3+1
			getitem/"listn",i3/"it"
			if/[it == in2]
				set/"i3",len2/"con",1
			endif
		endloop
		if/[con == 1]
			getindex/"listn",in2/"ix"
			print/"ix=",ix,\n
			print/"file=",file,\n
			replace/ix,file/"listc"
		else
			append/in2/"listn"
			append/file/"listc"
		endif
}
linkdef/"emc25","emc37","global"
{
	// Add user.
	// 25/[username]
	set/"err",""
	if/[whoami == "root"]
		getitem/"argument1",1/"in"
		// Add user
		bintolist/$USERS/"USERS"
		getindex/"USERS",in/"ix"
		if/[ix == 0]
			append/in/"USERS"
		else
			set/"err","User '",in,"' already exists"
		endif
		if/[err == ""]
			// Create a group for the user
			bintolist/$GROUPS/"GROUPS"
			getindex/"GROUPS",in/"ix"
			if/[ix == 0]
				append/in/"GROUPS"
			else
				set/"msg","25: Warning: Group '",in,"' already exists"
				source/$tmp_lib_pidkmsg/255123000,msg
			endif
			// Add the user to its group
			bintolist/$GROUP_USERS/"GROUP_USERS"
			getindex/"GROUPS",in/"ix"
			getitem/"GROUP_USERS",ix/"it"
			bintolist/it/"group"
			getindex/"group",in/"ix"
			if/[ix == 0]
				append/in/"group"
			else
				set/"msg","25: Warning: User '",in,"' is already in group '",in,"'"
				source/$tmp_lib_pidkmsg/255123000,msg
			endif
			listtobin/"group"/"it"
			getindex/"GROUPS",in/"ix"
			replace/ix,it/"GROUP_USERS"
		endif
	else
		set/"err","Permission denied"
	endif
	if/[err == ""]
		// Sync changes
		listtobin/"USERS"/"$USERS"
		listtobin/"GROUPS"/"$GROUPS"
		listtobin/"GROUP_USERS"/"$GROUP_USERS"
	else
		set/"msg","25: Failed to add user: ",err
		source/$tmp_lib_pidkmsg/255000000,msg
	endif
	
}
linkdef/"emc26","emc38","global"
{
	// Beep.
	// 26/[frequency],[duration in seconds]
	getitem/"argument1",1/"in1"
	getitem/"argument1",2/"in2"
	beep/in1,in2
}
linkdef/"emc27","emc39","global"
{
	// Remove item from list.
	// 27/[item]/[list name]
	getitem/"argument1",1/"in1"
	getitem/"argument2",1/"in3"
	getlistlength/"listn"/"len2"
	set/"i3",0/"con",0
	while/[i3 < len2]
		calc/"i3=i3+1
		getitem/"listn",i3/"it"
		if/[it == in3]
			set/"i3",len2/"con",1
		endif
	endloop
	if/[con == 1]
		getindex/"listn",in2/"ix"
		getitem/"listc",ix/"it"
		bintolist/it/"new"
		deleteitem/in1/"new"
		listtobin/"new"/"it"
		replace/ix,it/"listc"
	else
		append/in2/"listn"
		append/""/"listc"
	endif
}
linkdef/"emc28","emc40","global"
{
	// Delete user.
	// 28/[username]
	set/"err",""
	if/[whoami == "root"]
		getitem/"argument1",1/"in"
		bintolist/$USERS/"USERS"
		getindex/"USERS",in/"ix"
		if/[ix == 0]
			set/"err","User '",in,"' not found"
		else
			// Delete user
			if/[in == "root"]
				set/"err","User 'root' can't be deleted"
			else
				deleteitem/ix/"USERS"
				listtobin/"USERS"/"$USERS"
				// Delete the user from all groups
				bintolist/$GROUP_USERS/"GROUP_USERS"
				getlistlength/"GROUP_USERS"/"len"
				set/"i3",0
				repeat/len
					calc/"i3=i3+1"
					getitem/"GROUP_USERS",i3/"it"
					bintolist/it/"group"
					set/"ix",1
					while/[ix != 0]
						getindex/"group",in/"ix"
						deleteitem/ix/"group"
					endloop
					listtobin/"group"/"it"
					replace/i3,it/"GROUP_USERS"
				endloop
				listtobin/"GROUP_USERS"/"$GROUP_USERS"
			endif
		endif
	else
		set/"err","Permission denied"
	endif
	if/[err != ""]
		set/"msg","28: Failed to delete user: ",err
		source/$tmp_lib_pidkmsg/255000000,msg
	endif
}
linkdef/"emc29","emc41","global"
{
	// Add group.
	// 29/[group name]
	set/"err",""
	if/[whoami == "root"]
		getitem/"argument1",1/"in"
		bintolist/$GROUPS/"GROUPS"
		getindex/"GROUPS",in/"ix"
		if/[ix == 0]
			append/in/"GROUPS"
			listtobin/"GROUPS"/"$GROUPS"
		else
			set/"err","Group '",in,"' already exists"
		endif
	else
		set/"err","Permission denied"
	endif
	if/[err != ""]
		set/"msg","29: Failed to add group: ",err
		source/$tmp_lib_pidkmsg/255000000,msg
	endif
}
linkdef/"emc2A","emc42","global"
{
	// Delete group.
	// 2A/[group name]
	set/"err",""
	if/[whoami == "root"]
		getitem/"argument1",1/"in"
		bintolist/$GROUPS/"GROUPS"
		getindex/"GROUPS",in/"ix"
		if/[ix == 0]
			set/"err","Group '",in,"' not found"
		else
			if/[in == "root"]
				set/"err","Group 'root' can't be deleted"
			else
				deleteitem/ix/"GROUPS"
				listtobin/"GROUPS"/"$GROUPS"
			endif
		endif
	else
		set/"err","Permission denied"
	endif
	if/[err != ""]
		set/"msg","2A: Failed to delete group: ",err
		source/$tmp_lib_pidkmsg/255000000,msg
	endif
}
linkdef/"emc2B","emc43","global"
{
	// Switch power state.
	// 2B/[ID]
	// 1 - shutdown
	// 2 - reboot
	if/[whoami == "root"]
		getitem/"argument1",1/"in"
		if/[in == 1]
			source/$tmp_lib_poweroff/1
		else
			if/[in == 2]
				source/$tmp_lib_reboot/1
			else
				set/"msg","2B: Unknown power state: ",in
				source/$tmp_lib_pidkmsg/255000000,msg
			endif
		endif
	else
		source/$tmp_lib_pidkmsg/255000000,"2B: Switch power state failed: Permission denied"
	endif
}
linkdef/"emc2C","emc44","global"
{
	// Add user to group.
	// 2C/[username]/[group name]
	set/"err",""
	getitem/"argument1",1/"in1"
	getitem/"argument2",1/"in2"
	if/[whoami == "root"] or [whoami == in2]
		// Check if the user exists
		bintolist/$USERS/"USERS"
		getindex/"USERS",in1/"ix"
		if/[ix == 0]
			set/"err","This user doesn't exist"
		else
			// Check if the group exists
			bintolist/$GROUPS/"GROUPS"
			getindex/"GROUPS",in2/"ix"
			if/[ix == 0]
				set/"err","This group doesn't exist"
			else
				// Check, if the user isn't already in the group
				bintolist/$GROUP_USERS/"GROUP_USERS"
				getitem/"GROUP_USERS",ix/"it"
				bintolist/it/"group"
				getindex/"group",in1/"ix"
				if/[ix == 0]
					// Add the user to the group
					append/in1/"group"
					// Sync the changes
					listtobin/"group"/"it"
					getindex/"GROUPS",in2/"ix"
					replace/ix,it/"GROUP_USERS"
					listtobin/"GROUP_USERS"/"$GROUP_USERS"
				else
					set/"err","User is already in the group"
				endif
			endif
		endif
	else
		set/"err","Permission denied"
	endif
	if/[err != ""]
		set/"msg","2C: Failed to add user '",in1,"' to group '",in2,"': ",err
		source/$tmp_lib_pidkmsg/255000000,msg
	endif
}
linkdef/"emc2D","emc45","global"
{
	// Delete user from group.
	// 2D/[username]/[group name]
	set/"err",""
	getitem/"argument1",1/"in1"
	getitem/"argument2",1/"in2"
	if/[whoami == "root"] or [whoami == in2]
		// Check if the group exists
		bintolist/$GROUPS/"GROUPS"
		getindex/"GROUPS",in2/"ix"
		if/[ix == 0]
			set/"err","This group doesn't exist"
		else
			// Check, if the user is in the group
			bintolist/$GROUP_USERS/"GROUP_USERS"
			getitem/"GROUP_USERS",ix/"it"
			bintolist/it/"group"
			getindex/"group",in1/"ix"
			if/[ix == 0]
				set/"err","User is not in the group"
			else
				// Delete the user from the group
				deleteitem/ix/"group"
				// Sync the changes
				listtobin/"group"/"it"
				getindex/"GROUPS",in2/"ix"
				replace/ix,it/"GROUP_USERS"
				listtobin/"GROUP_USERS"/"$GROUP_USERS"
			endif
		endif
	else
		set/"err","Permission denied"
	endif
	if/[err != ""]
		set/"msg","2D: Failed to delete user '",in1,"' from group '",in2,"': ",err
		source/$tmp_lib_pidkmsg/255000000,msg
	endif
}
linkdef/"emc2E","emc46","global"
{
	// Get list of users.
	// 2E/[output list]
	if/[whoami == "root"]
		getitem/"argument1",1/"in"
		getindex/"listn",in/"ix"
		if/[ix == 0]
			append/in/"listn"
			append/$USERS/"listc"
		else
			replace/ix,$USERS/"listc"
		endif
	else
		source/$tmp_lib_pidkmsg/255000000,"2E: Unable to read user list: Permission denied"
	endif
}
linkdef/"emc2F","emc47","global"
{
	// Get list of groups.
	// 2F/[output list]
	if/[whoami == "root"]
		getitem/"argument1",1/"in"
		getindex/"listn",in/"ix"
		if/[ix == 0]
			append/in/"listn"
			append/$GROUPS/"listc"
		else
			replace/ix,$GROUPS/"listc"
		endif
	else
		source/$tmp_lib_pidkmsg/255000000,"2E: Unable to read group list: Permission denied"
	endif
}
linkdef/"emc30","emc48","global"
{
	// Get list of users in a group.
	// 30/[group name]/[output list]
	set/"err",""
	getitem/"argument1",1/"in1"
	getitem/"argument2",1/"in2"
	if/[whoami == "root"] or [whoami == in1]
		bintolist/$GROUPS/"GROUPS"
		getindex/"GROUPS",in1/"ix"
		if/[ix == 0]
			set/"err","Group '",in1,"' not found"
		else
			bintolist/$GROUP_NAMES/"GROUP_NAMES"
			getitem/"GROUP_NAMES",ix/"it"
			getindex/"listn",in2/"ix"
			if/[ix == 0]
				append/in2/"listn"
				append/it/"listc"
			else
				replace/ix,it/"listc"
			endif
		endif
	else
		set/"err","Permission denied"
	endif
	if/[err != ""]
		set/"msg","2D: Unable to read group '",in1,"': ",err
		source/$tmp_lib_pidkmsg/255000000,msg
	endif
}
//linkdef/"emc31","emc49","global"
//{
	// Reserved
//}
//linkdef/"emc32","emc50","global"
//{
	// Reserved
//}
linkdef/"emc33","emc51","global"
{
	// Convert binary to list.
	// 33/[binary]/[list name]
	getitem/"argument1",1/"in1"
	getitem/"argument2",1/"in2"
	getlistlength/"listn"/"len2"
	set/"i3",0/"con",0
	while/[i3 < len2]
		calc/"i3=i3+1
		getitem/"listn",i3/"it"
		if/[it == in2]
			set/"i3",len2/"con",1
		endif
	endloop
	if/[con == 1]
		getindex/"listn",in2/"ix"
		replace/ix,in1/"listc"
	else
		append/in2/"listn"
		append/in1/"listc"
	endif
}
linkdef/"emc34","emc52","global"
{
	// Convert list to binary.
	// 34/[list name]/[variable name]
	getitem/"argument1",1/"in1"
	getitem/"argument2",1/"in2"
	getindex/"listn",in1/"ix"
	getitem/"listc",ix/"it"
	source/$tmp_lib_set/in2,it
}
linkdef/"emc35","emc53","global"
{
	// Read variable.
	// 35/[variable name]/[output variable name]
	bintolist/$gl_vn/"gl_vn"
	bintolist/$gl_vv/"gl_vv"
	getitem/"argument1",1/"in1"
	getitem/"argument2",1/"in2"
	getletter/in1,1/"let"
	if/[let == "$"]
		getindex/"gl_vn",in1/"ix"
		getitem/"gl_vv",ix/"it"
	else
		getindex/"vn",in1/"ix"
		getitem/"vv",ix/"it"
	endif
	source/$tmp_lib_set/in2,it
}
linkdef/"emc36","emc54","global"
{
	// Get index of an item.
	// 36/[list name],[string]/[output variable name]
	getitem/"argument1",1/"in1"
	getitem/"argument1",2/"in2"
	getitem/"argument2",1/"in3"
	getindex/"listn",in1/"ix"
	getitem/"listc",ix/"bin"
	bintolist/bin/"list"
	getindex/"list",in2/"it"
	source/$tmp_lib_set/in3,it
}
linkdef/"emc37","emc55","global"
{
	// Interpret SMC instruction.
	// 37/[input list name],[index],[var names list],[var values list],[global var names list],[global var values list]/[index2 var name],[command list name],[argument lists prefix]
	//
	// The code below is unfinished! Virtualization support
	// is going to come later. Tell us if you're interested in the porting process :)
	//
	//getitem/"argument1",1/"in1"
	//getitem/"argument1",2/"in2"
	//getitem/"argument1",3/"in3"
	//getitem/"argument1",4/"in4"
	//getitem/"argument1",5/"in5"
	//getitem/"argument1",6/"in6"
	//getitem/"argument2",1/"in7"
	//getitem/"argument2",2/"in8"
	//getitem/"argument2",3/"in9"
	//getindex/"listn",in1/"ix"
	//getitem/"listc",ix/"list"
	//smc_getarg/"list",in2,"tmpvn","tmpvv","tmpglvn","tmpglvv"/"tmpsi2","cmd","tmparg"
	//
	source/$tmp_lib_pidkmsg/255255000,"Virtualization isn't supported yet!"
}
linkdef/"emc38","emc56","global"
{
	// Calculate absolute value.
	// 38/[input]/[output variable]
	getitem/"argument1",1/"in1"
	getitem/"argument2",1/"in2"
	abs/in1/"it"
	source/$tmp_lib_set/in2,it
}
linkdef/"_runcommand","rcmd","global"
{
	getitem/"command",1/"opcode"
	// Uncomment if needed for debugging:
	//print/si,": ",opcode,\n
	set/"opcode","0x",opcode
	add/opcode,0/"opcode"
	set/"emcop","$tmp_lib_emc",opcode
	readvar/emcop/"emcop"
	source/emcop
}
// --- END EMC instructions ---
linkdef/"_start","start","global"
{
	// _start/[binary],[wait or bg],[user]/[passed arguments - in ONE input as a binary]
	warp
		add/$ps,1/"$ps"
		getitem/"arg_1",1/"bin"
		getitem/"arg_1",2/"temp"
		getitem/"arg_1",3/"user"
		if/[arg_count > 1]
			getitem/"arg_2",1/"args"
		else
			set/"args",""
		endif
	endwarp
	run/$tmp_lib_emc,temp/bin,$ps,user/args
}
linkdef/"_emc","emc","global"
{
	//warp
		// _emc/[binary],[pid],[user]/[passed arguments - in ONE input as a binary]
		//
		// It's better to run this function
		// without screen refresh (warp)
		// Instructions that can't run properly with warp
		// will enter non-warp mode automatically
		getitem/"arg_1",1/"script_bin"
		getitem/"arg_1",2/"pid"
		getitem/"arg_1",3/"whoami"
		getitem/"arg_2",1/"pargs"
		bintolist/script_bin/"script"
		getlength/pargs/"len"
		bintolist/pargs/"args"
		getlistlength/"args"/"len"
		append/"arg_count"/"vn"
		append/len/"vv"
		set/"si",0
		repeat/len
			calc/"si=si+1"
			getitem/"args",si/"arg"
			set/"temp","arg_",si
			append/temp/"listn"
			append/arg/"listc"
		endloop
		set/"envrt",0
		source/$tmp_lib_envsetup
		if/[envrt != 0]
			set/"msg","crashed with error ",envrt
			source/$tmp_lib_pidkmsg/255000000,msg
			exit
		endif
		set/"msg","started as user '",whoami,"'"
		source/$tmp_lib_pidkmsg/255255255,msg
		getlistlength/"script"/"slen"
		bintolist/$gl_vn/"gl_vn"
		bintolist/$gl_vv/"gl_vv"
		set/"si",0
		while/[si < slen]
			calc/"si=si+1"
			source/$tmp_lib_envupdate
			smc_getarg/"script",si,"vn","vv","gl_vn","gl_vv"/"si2","command","argument"
			set/"res1",si2
			source/$tmp_lib_rcmd
			set/"si",res1
		endloop
		if/[si < slen]
			source/$tmp_lib_pidkmsg/255255000,"Crashed for unknown reason!"
		endif
		source/$tmp_lib_pidkmsg/255255255,"stopped"
	//endwarp
}
linkdef/"_userspace_setup","us_setup","local"
{
	warp
		set/"$ps",0/"$gl_vn",""/"$gl_vv",""
		set/"$GROUPS","4;root"/"$USERS","4;root"/"$GROUP_USERS","6;4;root"
	endwarp
}
warp
	clear
	// Prevent kernel args from overwriting
	listtobin/"arg_1"/"kab"
	bintolist/kab/"kargs"
	set/"kacount",arg_count
	// Kernel start message
	set/"$kstart",%time
	kmsg/"",255255255,"EarthOS kernel loaded"
	hidelogo
endwarp
// Process args
if/[kacount > 1]
	PANIC/"Only one SMC argument can be passed to the kernel."
endif
warp
	set/"cm","Kernel command line: "
	setlist/"KERNEL_INPUTS"
	getlistlength/"kargs"/"inputs"
	set/"i",0
	while/[i < inputs]
		calc/"i=i+1"
		getitem/"kargs",i/"input"
		getlength/input/"inputlen"
		setlist/"inputparts"
		set/"inputpart",""
		set/"i2",0
		while/[i2 < inputlen]
			calc/"i2=i2+1"
			getletter/input,i2/"letter"
			if/[letter == "="]
				append/inputpart/"inputparts"
				set/"inputpart",""
			else
				set/"inputpart",inputpart,letter
			endif
		endloop
		append/inputpart/"inputparts"
		getitem/"inputparts",1/"setname"
		getitem/"inputparts",2/"inputvalue"
		set/"cm",cm,setname,"=",inputvalue," "
		set/"setname","KERNEL_INPUT_",setname
		set/setname,inputvalue
	endloop
	kmsg/"",255255255,cm
endwarp
// Map devices
kmsg/"",255255255,"Mapping devices..."
warp
	listdisk/"disks"
	getlistlength/"disks"/"dc"
	kmsg/"",255255255,"Found ",dc," disk(s)"
	set/"ki",0/"ab","abcdefghijklmnopqrstuvwxyz"
	getlength/ab/"abl"
	repeat/dc
		calc/"ki=ki+1"
		if/[ki > abl]
			PANIC/"Max number of disks is 26 (for now)!"
		endif
		getletter/ab,ki/"let"
		set/"mn","$/dev/sd",let
		set/mn,ki/"mn2","sd",let
		cpdisk/ki,1/"dbin"
		kmsg/"",255255255,"d",ki," -> ",mn2
		_listpart/dbin/"pt","pts","ptd"
		getlistlength/"pt"/"pc"
		kmsg/"",255255255,mn2,": Found ",pc," partition(s)"
		set/"ki2",0
		repeat/pc
			calc/"ki2=ki2+1"
			set/"mn3",mn,ki2
			set/mn3,ki,",",ki2
			set/"mn4",mn2,ki2
			kmsg/"",255255255,"d",ki,",",ki2," -> ",mn4
		endloop
	endloop
endwarp
// Mount rootfs
kmsg/"","000255000","Mounting root filesystem..."
warp
	if/[KERNEL_INPUT_root == ""]
		PANIC/"root parameter not specified"
	endif
	// resolve root parameter
	resolvedev/KERNEL_INPUT_root
	getitem/"dl",1/"d"
	cpdisk/d,1/"dbin"
	_listpart/dbin/"pt","pts","ptd"
	getitem/"dl",2/"p"
	getitem/"ptd",p/"$rootfs"
	// Verify rootfs
	kmsg/"","000255000","Verifying root filesystem..."
	// reqdirs is a list of required directories in /
	setlist/"reqdirs"/"dev","sys"
	_ls/"/",$rootfs/"ftypes","fnames","fdata"
	getlistlength/"reqdirs"/"len"
	set/"i",0
	repeat/len
		calc/"i=i+1"
		getitem/"reqdirs",i/"it"
		getindex/"fnames",it/"ix"
		if/[ix == 0]
			set/"it","/",it,": No such file or directory"
			PANIC/it
		endif
	endloop
	// Start init
	kmsg/"","000255000","Executing /sbin/init"
	_ls/"/sbin",$rootfs/"ftypes","fnames","fdata"
	getlistlength/"fnames"/"fcount"
	getindex/"fnames","init"/"ix"
	if/[ix == 0]
		PANIC/"/sbin/init: No such file or directory"
	else
		getitem/"fdata",ix/"fd"
	endif
	_userspace_setup
endwarp
_start/fd,"wait","root"
// Panic after init stops
PANIC/"Attempted to kill init!"
